import sys

# hyper parameters
ARCH = "x86"
CONTENT_LENGTH = _  # (1)

# create shellcode
if ARCH == "x86_64":
    n_bit = 8  # size of char
    shellcode = _
elif ARCH == "x86":
    n_bit = 4
    shellcode = _  # (2)

# Fill the badfile_content with NOP (0x90)
badfile_content = bytearray(0x90 for i in range(CONTENT_LENGTH))

print("length of badfile content is ", badfile_content)
print("size of char is ", n_bit)
print("length of shellcode is ", len(shellcode))

"""TASK A

Write Return Address into Badfile
"""
# compute offset of "Return Address" using memory address in gdb
gdb_mem_addr_stack = _  # (3)
gdb_mem_addr_buffer = _  # (4)
offset_ret = _  # (5)

# set new value for the "Return Address"

# true memory address of buffer, decided by the running env
# for example, if you run ./stack in terminal, true_mem_addr_buffer might is different from gdb_mem_addr_buffer found in gdb
true_mem_addr_buffer = _  # (6)
value_ret = _  # (7)
badfile_content[offset_ret : offset_ret + n_bit] = value_ret.to_bytes(n_bit, "little")

print("offset of return address is ", offset_ret, hex(offset_ret))
print("value of return address is ", hex(value_ret))

"""TASK B

Inject Malicious Code into Badfile
"""

offset_shellcode = _  # (8)
badfile_content[offset_shellcode : offset_shellcode + len(shellcode)] = shellcode

print("offset of shellcode is ", offset_shellcode, hex(offset_shellcode))

# Write the badfile_content to a file
with open("badfile", "wb") as f:
    f.write(badfile_content)
